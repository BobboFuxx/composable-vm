# generated by datamodel-codegen:
#   filename:  response_to_get_all_asset_venues.json

from __future__ import annotations

from enum import Enum
from typing import List, Union

from pydantic import BaseModel, ConfigDict, Field, RootModel


class AssetId(RootModel[str]):
    root: str = Field(
        ...,
        description='Newtype for CVM assets ID. Must be unique for each asset and must never change. This ID is an opaque, arbitrary type from the CVM protocol and no assumption must be made on how it is computed.',
    )


class DisplayedForUint128(RootModel[str]):
    root: str = Field(
        ...,
        description='A wrapper around a type which is serde-serialised as a string.\n\nFor serde-serialisation to be implemented for the type `T` must implement `Display` and `FromStr` traits.\n\n```rust use cvm::shared::Displayed;\n\n#[derive(serde::Serialize, serde::Deserialize)] struct Foo { value: Displayed<u64> }\n\nlet encoded = serde_json_wasm::to_string(&Foo { value: Displayed(42) }).unwrap(); assert_eq!(r#"{"value":"42"}"#, encoded);\n\nlet decoded = serde_json_wasm::from_str::<Foo>(r#"{"value":"42"}"#).unwrap(); assert_eq!(Displayed(42), decoded.value); ```',
    )


class VenueId3(Enum):
    transfer = 'transfer'


class VenueId4(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    exchange: DisplayedForUint128


class VenueId(RootModel[Union[VenueId3, VenueId4]]):
    root: Union[VenueId3, VenueId4]


class AssetsVenueItem(BaseModel):
    """
    assets which can be transomed into each other via venue
    """

    from_asset_id: AssetId
    to_asset_id: AssetId
    venue_id: VenueId


class ArrayOfAssetsVenueItem(RootModel[List[AssetsVenueItem]]):
    root: List[AssetsVenueItem] = Field(..., title='Array_of_AssetsVenueItem')
