# generated by datamodel-codegen:
#   filename:  skip_money_swagger.yml

from __future__ import annotations

from enum import Enum
from typing import Any, List, Optional, Union

from pydantic import BaseModel, Field, RootModel


class AcknowledgementErrorDetails(BaseModel):
    code: Optional[float] = Field(None, description='Error code')
    message: Optional[str] = Field(None, description='Error message')


class Affiliate(BaseModel):
    """
    An affiliate that receives fees from a swap
    """

    address: Optional[str] = Field(None, description='Address to which to pay the fee')
    basis_points_fee: Optional[str] = Field(
        None, description='Bps fee to pay to the affiliate'
    )


class ApiError(BaseModel):
    message: Optional[str] = Field(None, description='Error message')


class Asset(BaseModel):
    chain_id: Optional[str] = Field(None, description='Chain-id of the asset')
    coingecko_id: Optional[str] = Field(None, description='Coingecko id of the asset')
    decimals: Optional[float] = Field(
        None, description='Number of decimals used for amounts of the asset'
    )
    denom: Optional[str] = Field(None, description='Denom of the asset')
    description: Optional[str] = Field(None, description='Description of the asset')
    is_cw20: Optional[bool] = Field(
        None, description='Indicates whether asset is a CW20 token'
    )
    is_evm: Optional[bool] = Field(
        None, description='Indicates whether asset is an EVM token'
    )
    is_svm: Optional[bool] = Field(
        None, description='Indicates whether asset is an SVM token'
    )
    logo_uri: Optional[str] = Field(
        None, description='URI pointing to an image of the logo of the asset'
    )
    name: Optional[str] = Field(None, description='Name of the asset')
    origin_chain_id: Optional[str] = Field(
        None,
        description='Chain-id of the origin of the asset. If this is an ibc denom, this is the chain-id of the asset that the ibc token represents',
    )
    origin_denom: Optional[str] = Field(
        None,
        description='Denom of the origin of the asset. If this is an ibc denom, this is the original denom that the ibc token represents',
    )
    recommended_symbol: Optional[str] = Field(
        None,
        description='Recommended symbol of the asset used to differentiate between bridged assets with the same symbol, e.g. USDC.axl for Axelar USDC and USDC.grv for Gravity USDC',
    )
    symbol: Optional[str] = Field(
        None, description='Symbol of the asset, e.g. ATOM for uatom'
    )
    token_contract: Optional[str] = Field(
        None,
        description='Address of the contract for the asset, e.g. if it is a CW20 or ERC20 token',
    )
    trace: Optional[str] = Field(
        None,
        description='The forward slash delimited sequence of ibc ports and channels that can be traversed to unwind an ibc token to its origin asset.',
    )


class AutopilotAction(Enum):
    LIQUID_STAKE = 'LIQUID_STAKE'
    CLAIM = 'CLAIM'


class AutopilotMsg(BaseModel):
    action: Optional[AutopilotAction] = None
    receiver: Optional[str] = None


class AutopilotMsgWrapper(BaseModel):
    autpilot_msg: Optional[AutopilotMsg] = None


class AxelarTransferState(Enum):
    """
    Axelar transfer state: <br/> * AXELAR_TRANSFER_UNKNOWN - Unknown error <br/> * AXELAR_TRANSFER_PENDING_CONFIRMATION - Axelar transfer is pending confirmation <br/> * AXELAR_TRANSFER_PENDING_RECEIPT - Axelar transfer is pending receipt at destination <br/> * AXELAR_TRANSFER_SUCCESS - Axelar transfer succeeded and assets have been received <br/> * AXELAR_TRANSFER_FAILURE - Axelar transfer failed <br/>

    """

    AXELAR_TRANSFER_UNKNOWN = 'AXELAR_TRANSFER_UNKNOWN'
    AXELAR_TRANSFER_PENDING_CONFIRMATION = 'AXELAR_TRANSFER_PENDING_CONFIRMATION'
    AXELAR_TRANSFER_PENDING_RECEIPT = 'AXELAR_TRANSFER_PENDING_RECEIPT'
    AXELAR_TRANSFER_SUCCESS = 'AXELAR_TRANSFER_SUCCESS'
    AXELAR_TRANSFER_FAILURE = 'AXELAR_TRANSFER_FAILURE'


class AxelarTransferType(Enum):
    """
    Axelar transfer type: <br/> * AXELAR_TRANSFER_CONTRACT_CALL_WITH_TOKEN - GMP contract call with token transfer type <br/> * AXELAR_TRANSFER_SEND_TOKEN - Send token transfer type <br/>

    """

    AXELAR_TRANSFER_CONTRACT_CALL_WITH_TOKEN = (
        'AXELAR_TRANSFER_CONTRACT_CALL_WITH_TOKEN'
    )
    AXELAR_TRANSFER_SEND_TOKEN = 'AXELAR_TRANSFER_SEND_TOKEN'


class CCTPTransferState(Enum):
    """
    CCTP transfer state: <br/> * CCTP_TRANSFER_UNKNOWN - Unknown error <br/> * CCTP_TRANSFER_SENT - The burn transaction on the source chain has executed <br/> * CCTP_TRANSFER_PENDING_CONFIRMATION - CCTP transfer is pending confirmation by the cctp attestation api <br/> * CCTP_TRANSFER_CONFIRMED - CCTP transfer has been confirmed by the cctp attestation api <br/> * CCTP_TRANSFER_RECEIVED - CCTP transfer has been received at the destination chain
    """

    CCTP_TRANSFER_UNKNOWN = 'CCTP_TRANSFER_UNKNOWN'
    CCTP_TRANSFER_SENT = 'CCTP_TRANSFER_SENT'
    CCTP_TRANSFER_PENDING_CONFIRMATION = 'CCTP_TRANSFER_PENDING_CONFIRMATION'
    CCTP_TRANSFER_CONFIRMED = 'CCTP_TRANSFER_CONFIRMED'
    CCTP_TRANSFER_RECEIVED = 'CCTP_TRANSFER_RECEIVED'


class BankSend(BaseModel):
    chain_id: Optional[str] = Field(
        None, description='Chain-id of the chain that the transaction is intended for'
    )
    denom: Optional[str] = Field(None, description='Denom of the asset to send')


class BankSendWrapper(BaseModel):
    bank_send: Optional[BankSend] = None


class BridgeType(Enum):
    """
    Bridge Type: <br/> * IBC - IBC Bridge <br/> * AXELAR - Axelar Bridge <br/> * CCTP - CCTP Bridge <br/> * HYPERLANE - Hyperlane Bridge
    """

    IBC = 'IBC'
    AXELAR = 'AXELAR'
    CCTP = 'CCTP'
    HYPERLANE = 'HYPERLANE'


class ContractCallWithTokenErrorType(Enum):
    """
    ContractCallWithToken errors: <br/> * CONTRACT_CALL_WITH_TOKEN_EXECUTION_ERROR - Error occurred during the execute transaction <br/>

    """

    CONTRACT_CALL_WITH_TOKEN_EXECUTION_ERROR = (
        'CONTRACT_CALL_WITH_TOKEN_EXECUTION_ERROR'
    )


class CosmWasmContractMsg(BaseModel):
    contract_address: Optional[str] = Field(
        None, description='Address of the contract to execute the message on'
    )
    msg: Optional[str] = Field(None, description='JSON string of the message')


class CosmWasmContractMsgWrapper(BaseModel):
    wasm_msg: Optional[CosmWasmContractMsg] = None


class Erc20Approval(BaseModel):
    """
    An ERC20 token contract approval
    """

    amount: Optional[str] = Field(None, description='Amount of the approval')
    spender: Optional[str] = Field(None, description='Address of the spender')
    token_contract: Optional[str] = Field(
        None, description='Address of the ERC20 token contract'
    )


class Reason1(Enum):
    """
    Error detail: <br/> * LOW_INFO_ERROR - Not enough asset pricing information to determine the price safety of the route. <br/> * BAD_PRICE_ERROR - The execution price of the route deviates significantly from the current market price.
    """

    LOW_INFO_ERROR = 'LOW_INFO_ERROR'
    BAD_PRICE_ERROR = 'BAD_PRICE_ERROR'


class ErrorDetail(BaseModel):
    reason: Optional[Reason1] = Field(
        None,
        description='Error detail: <br/> * LOW_INFO_ERROR - Not enough asset pricing information to determine the price safety of the route. <br/> * BAD_PRICE_ERROR - The execution price of the route deviates significantly from the current market price. ',
    )


class CosmosMsg(BaseModel):
    """
    A message in a cosmos transaction
    """

    msg: Optional[str] = Field(None, description='JSON string of the message')
    msg_type_url: Optional[str] = Field(None, description='TypeUrl of the message')


class CosmosTx(BaseModel):
    """
    A transaction on a Cosmos chain
    """

    chain_id: Optional[str] = Field(
        None, description='Chain-id of the chain that the transaction is intended for'
    )
    path: Optional[List[str]] = Field(
        None,
        description='Path of chain-ids that the message is intended to interact with',
    )
    msgs: Optional[List[CosmosMsg]] = Field(
        None,
        description='The messages that should be included in the transaction. The ordering must be adhered to.',
    )


class CosmosTxWrapper(BaseModel):
    cosmos_tx: Optional[CosmosTx] = None


class EvmTx(BaseModel):
    """
    A transaction on an EVM chain
    """

    chain_id: Optional[str] = Field(
        None, description='Chain-id of the chain that the transaction is intended for'
    )
    data: Optional[str] = Field(None, description='Data of the transaction')
    required_erc20_approvals: Optional[List[Erc20Approval]] = Field(
        None, description='ERC20 approvals required for the transaction'
    )
    to: Optional[str] = Field(
        None, description='Address of the recipient of the transaction'
    )
    value: Optional[str] = Field(None, description='Amount of the transaction')


class EvmTxWrapper(BaseModel):
    evm_tx: Optional[EvmTx] = None


class SvmTx(BaseModel):
    """
    A transaction on an SVM chain
    """

    chain_id: Optional[str] = Field(
        None, description='Chain-id of the chain that the transaction is intended for'
    )
    tx: Optional[str] = Field(
        None, description='Base64 encoded unsigned or partially signed transaction'
    )


class SvmTxWrapper(BaseModel):
    svm_tx: Optional[SvmTx] = None


class GasPriceInfo(BaseModel):
    """
    Gas price tiers
    """

    average: Optional[str] = Field(None, description='Average gas price')
    high: Optional[str] = Field(None, description='High gas price')
    low: Optional[str] = Field(None, description='Low gas price')


class FeeAsset(BaseModel):
    """
    Asset used to pay gas fees and the recommended price tiers. Assets and gas price recommendations are sourced from the [keplr chain registry](https://github.com/chainapsis/keplr-chain-registry)
    """

    denom: Optional[str] = Field(None, description='Asset denom')
    gas_price_info: Optional[GasPriceInfo] = Field(None, description='Gas price tiers')


class GRPCStatusCode(RootModel[float]):
    root: float = Field(
        ...,
        description='grpc status codes as defined [here](https://grpc.github.io/grpc/core/md_doc_statuscodes.html)',
    )


class HyperlaneTransfer(BaseModel):
    """
    A transfer facilitated by the Hyperlane bridge
    """

    from_chain_id: Optional[str] = Field(
        None,
        description='Canonical chain-id of the source chain of the bridge transaction',
    )
    to_chain_id: Optional[str] = Field(
        None,
        description='Canonical chain-id of the destination chain of the bridge transaction',
    )
    denom_in: Optional[str] = Field(None, description='Denom of the input asset')
    denom_out: Optional[str] = Field(None, description='Denom of the output asset')
    hyperlane_contract_address: Optional[str] = Field(
        None,
        description='Contract address of the hyperlane warp route contract that initiates the transfer',
    )
    fee_amount: Optional[str] = Field(
        None,
        description='Amount of the fee asset to be paid as the Hyperlane bridge fee. This is denominated in the fee asset.',
    )
    fee_asset: Optional[Asset] = None
    usd_fee_amount: Optional[str] = Field(
        None,
        description='Amount of the fee asset to be paid as the Hyperlane bridge fee, converted to USD value',
    )
    bridge_id: Optional[BridgeType] = None
    smart_relay: Optional[bool] = Field(
        None, description='Indicates whether this transfer is relayed via Smart Relay'
    )


class HyperlaneTransferState(Enum):
    """
    Hyperlane transfer state: <br/> * HYPERLANE_TRANSFER_UNKNOWN - Unknown error <br/> * HYPERLANE_TRANSFER_SENT - The Hyperlane transfer transaction on the source chain has executed <br/> * HYPERLANE_TRANSFER_FAILED - The Hyperlane transfer failed <br/> * HYPERLANE_TRANSFER_RECEIVED - The Hyperlane transfer has been received at the destination chain
    """

    HYPERLANE_TRANSFER_UNKNOWN = 'HYPERLANE_TRANSFER_UNKNOWN'
    HYPERLANE_TRANSFER_SENT = 'HYPERLANE_TRANSFER_SENT'
    HYPERLANE_TRANSFER_FAILED = 'HYPERLANE_TRANSFER_FAILED'
    HYPERLANE_TRANSFER_RECEIVED = 'HYPERLANE_TRANSFER_RECEIVED'


class HyperlaneTransferWrapper(BaseModel):
    hyperlane_transfer: Optional[HyperlaneTransfer] = None


class Tx(RootModel[Union[CosmosTxWrapper, EvmTxWrapper, SvmTxWrapper]]):
    root: Union[CosmosTxWrapper, EvmTxWrapper, SvmTxWrapper]


class MultiChainMsg(BaseModel):
    """
    A message that interacts with multiple chains
    """

    chain_id: Optional[str] = Field(
        None,
        description='Chain-id of the chain that the transaction containing the message is intended for',
    )
    msg: Optional[str] = Field(None, description='JSON string of the message')
    msg_type_url: Optional[str] = Field(None, description='TypeUrl of the message')
    path: Optional[List[str]] = Field(
        None,
        description='Path of chain-ids that the message is intended to interact with',
    )


class MultiChainMsgWrapper(BaseModel):
    multi_chain_msg: Optional[MultiChainMsg] = None


class OptionalAsset(BaseModel):
    asset: Optional[Asset] = None
    asset_found: Optional[bool] = Field(None, description='Whether the asset was found')


class PacketErrorType(Enum):
    """
    Packet error type: <br/> * PACKET_ERROR_UNKNOWN - Unknown error <br/> * PACKET_ERROR_ACKNOWLEDGEMENT - Packet acknowledgement error <br/> * PACKET_ERROR_TIMEOUT - Packet timed out <br/>

    """

    PACKET_ERROR_UNKNOWN = 'PACKET_ERROR_UNKNOWN'
    PACKET_ERROR_ACKNOWLEDGEMENT = 'PACKET_ERROR_ACKNOWLEDGEMENT'
    PACKET_ERROR_TIMEOUT = 'PACKET_ERROR_TIMEOUT'


class ChainTransaction(BaseModel):
    chain_id: Optional[str] = Field(
        None, description='Chain ID the packet event occurs on'
    )
    explorer_link: Optional[str] = Field(
        None, description='Link to the transaction on block explorer'
    )
    tx_hash: Optional[str] = Field(
        None, description='Hash of the transaction the packet event occurred in'
    )


class PostHandler(RootModel[Union[CosmWasmContractMsgWrapper, AutopilotMsgWrapper]]):
    root: Union[CosmWasmContractMsgWrapper, AutopilotMsgWrapper]


class Reason(Enum):
    """
    Recommendation reason: <br/> * UNKNOWN - Unknown recommendation reason. <br/> * MOST_LIQUID - Highest liquidity form of the transferred token on the destination chain. <br/> * BASE_TOKEN - The base token if the destination chain is the origin chain of the source token. <br/> * DIRECT - The token resulting from the least amount of transfers to the destination chain.

    """

    UNKNOWN = 'UNKNOWN'
    MOST_LIQUID = 'MOST_LIQUID'
    BASE_TOKEN = 'BASE_TOKEN'
    DIRECT = 'DIRECT'


class RoutePriceWarningType(Enum):
    """
    Recommendation reason: <br/> * LOW_INFO_WARNING - Not enough asset pricing information to determine the price safety of the route. <br/> * BAD_PRICE_WARNING - The execution price of the route deviates significantly from the current market price.
    """

    LOW_INFO_WARNING = 'LOW_INFO_WARNING'
    BAD_PRICE_WARNING = 'BAD_PRICE_WARNING'


class Warning(BaseModel):
    """
    Indicates if the route is unsafe due to poor execution price or if safety cannot be determined due to lack of pricing information
    """

    type: Optional[RoutePriceWarningType] = None
    message: Optional[str] = Field(None, description='Warning message')


class SendTokenErrorType(Enum):
    """
    SendToken error types: <br/> * SEND_TOKEN_EXECUTION_ERROR - Error occurred during the execute transaction <br/>

    """

    SEND_TOKEN_EXECUTION_ERROR = 'SEND_TOKEN_EXECUTION_ERROR'


class StatusErrorType(Enum):
    """
    Packet error type: <br/> * STATUS_ERROR_UNKNOWN - Unknown error <br/> * STATUS_ERROR_TRANSACTION_EXECUTION - Error was encountered during transaction execution <br/> * STATUS_ERROR_INDEXING - Error was encountered while indexing the transaction and packet data <br/> * STATUS_ERROR_TRANSFER - The transfer failed to complete successfully <br/>

    """

    STATUS_ERROR_UNKNOWN = 'STATUS_ERROR_UNKNOWN'
    STATUS_ERROR_TRANSACTION_EXECUTION = 'STATUS_ERROR_TRANSACTION_EXECUTION'
    STATUS_ERROR_INDEXING = 'STATUS_ERROR_INDEXING'
    STATUS_ERROR_TRANSFER = 'STATUS_ERROR_TRANSFER'


class SwapOperation(BaseModel):
    """
    Description of a single swap operation
    """

    denom_in: Optional[str] = Field(None, description='Input denom of the swap')
    denom_out: Optional[str] = Field(None, description='Output denom of the swap')
    pool: Optional[str] = Field(
        None, description='Identifier of the pool to use for the swap'
    )


class SwapVenue(BaseModel):
    """
    A venue on which swaps can be exceuted
    """

    chain_id: Optional[str] = Field(None, description='Chain-id of the swap venue')
    name: Optional[str] = Field(None, description='Name of the swap venue')


class TransactionExecutionErrorDetails(BaseModel):
    code: Optional[float] = Field(None, description='Error code')
    message: Optional[str] = Field(None, description='Error message')


class TransactionState(Enum):
    """
    Transaction state: <br/> * STATE_SUBMITTED - The initial transaction has been submitted to Skip API but not observed on chain yet. <br/> * STATE_PENDING - The initial transaction has been observed on chain, and there are still pending actions. <br/> * STATE_RECEIVED - The transfer asset has been released, but there are still packet events that are not indexed. <br/> * STATE_COMPLETED_SUCCESS - The initial transaction and any subsequent transfers have completed successfully and lifecycle tracking has concluded. <br/> * STATE_COMPLETED_ERROR - The initial transaction or a subsequent transfer failed and lifecycle tracking has concluded. <br/> * STATE_ABANDONED - Tracking for the transaction has been abandoned. This happens if the cross-chain  sequence of actions stalls for more than 10 minutes or if the initial transaction does not get observed in a block for 5 minutes. <br/> * STATE_PENDING_ERROR - The overall transaction will fail, pending error propagation.
    """

    STATE_SUBMITTED = 'STATE_SUBMITTED'
    STATE_PENDING = 'STATE_PENDING'
    STATE_RECEIVED = 'STATE_RECEIVED'
    STATE_COMPLETED_SUCCESS = 'STATE_COMPLETED_SUCCESS'
    STATE_COMPLETED_ERROR = 'STATE_COMPLETED_ERROR'
    STATE_ABANDONED = 'STATE_ABANDONED'
    STATE_PENDING_ERROR = 'STATE_PENDING_ERROR'


class Transfer(BaseModel):
    """
    A cross-chain transfer
    """

    from_chain_id: Optional[str] = Field(
        None, description='Chain-id on which the transfer is initiated'
    )
    to_chain_id: Optional[str] = Field(
        None, description='Chain-id on which the transfer is received'
    )
    channel: Optional[str] = Field(
        None, description='Channel to use to initiate the transfer'
    )
    dest_denom: Optional[str] = Field(
        None, description='Denom of the destionation asset of the transfer'
    )
    pfm_enabled: Optional[bool] = Field(
        None,
        description='Whether pfm is enabled on the chain where the transfer is initiated',
    )
    port: Optional[str] = Field(
        None, description='Port to use to initiate the transfer'
    )
    supports_memo: Optional[bool] = Field(
        None, description='Whether the transfer chain supports a memo'
    )
    denom_in: Optional[str] = Field(
        None, description='Denom of the input asset of the transfer'
    )
    denom_out: Optional[str] = Field(
        None, description='Denom of the output asset of the transfer'
    )
    fee_amount: Optional[str] = Field(
        None,
        description='Amount of the fee asset to be paid as the transfer fee if applicable.',
    )
    usd_fee_amount: Optional[str] = Field(
        None,
        description='Amount of the fee asset to be paid as the transfer fee if applicable, converted to USD value',
    )
    fee_asset: Optional[Asset] = Field(
        None, description='Asset to be paid as the transfer fee if applicable.'
    )
    bridge_id: Optional[BridgeType] = None
    smart_relay: Optional[bool] = Field(
        None, description='Indicates whether this transfer is relayed via Smart Relay'
    )


class TransferState(Enum):
    """
    Transfer state: <br/> * TRANSFER_UNKNOWN - Transfer state is not known. <br/> * TRANSFER_PENDING - The send packet for the transfer has been committed and the transfer is pending. <br/> * TRANSFER_RECEIVED - The transfer packet has been received by the destination chain. It can still fail and revert if it is part  of a multi-hop PFM transfer. <br/> * TRANSFER_SUCCESS - The transfer has been successfully completed and will not revert. <br/> * TRANSFER_FAILURE - The transfer has failed.

    """

    TRANSFER_UNKNOWN = 'TRANSFER_UNKNOWN'
    TRANSFER_PENDING = 'TRANSFER_PENDING'
    TRANSFER_RECEIVED = 'TRANSFER_RECEIVED'
    TRANSFER_SUCCESS = 'TRANSFER_SUCCESS'
    TRANSFER_FAILURE = 'TRANSFER_FAILURE'


class NextBlockingTransfer(BaseModel):
    """
    Indicates which entry in the `transfer_sequence` field that the transfer is blocked on. Will be null if there is no blocked transfer.
    """

    transfer_sequence_index: Optional[int] = Field(
        None,
        description='The index of the entry in the `transfer_sequence` field that the transfer is blocked on.',
    )


class TransferAssetRelease(BaseModel):
    """
    Indicates location and denom of transfer asset release.
    """

    chain_id: Optional[str] = Field(
        None,
        description='The chain ID of the chain that the transfer asset is released on.',
    )
    denom: Optional[str] = Field(
        None, description='The denom of the asset that is released.'
    )
    released: Optional[Any] = Field(
        None,
        description='Indicates whether assets have been released and are accessible. The assets may still be in transit.',
    )


class TransferWrapper(BaseModel):
    transfer: Optional[Transfer] = None


class RecommendationRequest(BaseModel):
    source_asset_denom: Optional[str] = Field(
        None, description='Denom of the source asset'
    )
    source_asset_chain_id: Optional[str] = Field(
        None, description='Chain-id of the source asset'
    )
    dest_chain_id: Optional[str] = Field(
        None, description='Chain-id of the recommended destination asset'
    )
    reason: Optional[Reason] = Field(
        None, description='Reason for recommendation (optional)'
    )


class CosmosModuleSupport(BaseModel):
    authz: Optional[bool] = Field(
        None, description='Whether the authz module is supported'
    )
    feegrant: Optional[bool] = Field(
        None, description='Whether the feegrant module is supported'
    )


class IbcCapabilities(BaseModel):
    cosmos_pfm: Optional[bool] = Field(
        None, description='Whether the packet forwarding middleware module is supported'
    )
    cosmos_ibc_hooks: Optional[bool] = Field(
        None, description='Whether the ibc hooks module is supported'
    )
    cosmos_memo: Optional[bool] = Field(
        None, description='Whether the chain supports IBC memos'
    )
    cosmos_autopilot: Optional[bool] = Field(
        None, description='Whether the autopilot module is supported'
    )


class FeeType(Enum):
    """
    Fee type: <br/> * SMART_RELAY - Fees for Smart relaying services.
    """

    SMART_RELAY = 'SMART_RELAY'


class Fee(BaseModel):
    fee_type: Optional[FeeType] = None
    bridge_id: Optional[BridgeType] = None
    amount: Optional[str] = Field(
        None, description='Amount of the fee asset to be paid'
    )
    usd_amount: Optional[str] = Field(None, description='The value of the fee in USD')
    origin_asset: Optional[Asset] = None
    chain_id: Optional[str] = Field(
        None, description='Chain ID of the chain where fees are collected'
    )
    tx_index: Optional[int] = Field(
        None,
        description='The index of the transaction in the list of transactions required to execute the transfer where fees are paid',
    )
    operation_index: Optional[int] = Field(
        None,
        description='The index of the operation in the returned operations list which incurs the fee',
    )


class AssetBetweenChains(BaseModel):
    asset_on_source: Optional[Asset] = None
    asset_on_dest: Optional[Asset] = None
    txs_required: Optional[int] = Field(
        None, description='Number of transactions required to transfer the asset'
    )
    bridges: Optional[List[BridgeType]] = Field(
        None, description='Bridges that are used to transfer the asset'
    )


class AssetRecommendation(BaseModel):
    asset: Optional[Asset] = Field(None, description='Asset that is recommended')
    reason: Optional[Reason] = Field(
        None, description='Reason for recommending the asset'
    )


class AxelarTransfer(BaseModel):
    """
    A transfer facilitated by the Axelar bridge
    """

    asset: Optional[str] = Field(None, description='Axelar-name of the asset to bridge')
    fee_amount: Optional[str] = Field(
        None,
        description='Amount of the fee asset to be paid as the Axelar bridge fee. This is denominated in the fee asset.',
    )
    fee_asset: Optional[Asset] = None
    from_chain: Optional[str] = Field(
        None,
        description='Name for source chain of the bridge transaction used on Axelar',
    )
    from_chain_id: Optional[str] = Field(
        None,
        description='Canonical chain-id of the source chain of the bridge transaction',
    )
    is_testnet: Optional[bool] = Field(
        None, description='Whether the source and destination chains are both testnets'
    )
    should_unwrap: Optional[bool] = Field(
        None,
        description='Whether to unwrap the asset at the destination chain (from ERC-20 to native)',
    )
    to_chain: Optional[str] = Field(
        None,
        description='Name for destination chain of the bridge transaction used on Axelar',
    )
    to_chain_id: Optional[str] = Field(
        None,
        description='Canonical chain-id of the destination chain of the bridge transaction',
    )
    denom_in: Optional[str] = Field(None, description='Denom of the input asset')
    denom_out: Optional[str] = Field(None, description='Denom of the output asset')
    usd_fee_amount: Optional[str] = Field(
        None,
        description='Amount of the fee asset to be paid as the Axelar bridge fee, converted to USD value',
    )
    ibc_transfer_to_axelar: Optional[Transfer] = None
    bridge_id: Optional[BridgeType] = None
    smart_relay: Optional[bool] = Field(
        None, description='Indicates whether this transfer is relayed via Smart Relay'
    )


class AxelarTransferWrapper(BaseModel):
    axelar_transfer: Optional[AxelarTransfer] = None


class CCTPTransfer(BaseModel):
    """
    A transfer facilitated by the CCTP bridge
    """

    from_chain_id: Optional[str] = Field(
        None,
        description='Canonical chain-id of the source chain of the bridge transaction',
    )
    to_chain_id: Optional[str] = Field(
        None,
        description='Canonical chain-id of the destination chain of the bridge transaction',
    )
    burn_token: Optional[str] = Field(
        None,
        description='Name of the asset to bridge. It will be the erc-20 contract address for EVM chains and `uusdc` for Noble.',
    )
    denom_in: Optional[str] = Field(None, description='Denom of the input asset')
    denom_out: Optional[str] = Field(None, description='Denom of the output asset')
    bridge_id: Optional[BridgeType] = None
    smart_relay: Optional[bool] = Field(
        None, description='Indicates whether this transfer is relayed via Smart Relay'
    )


class CCTPTransferTxs(BaseModel):
    send_tx: Optional[ChainTransaction] = None
    receive_tx: Optional[ChainTransaction] = None


class CCTPTransferWrapper(BaseModel):
    cctp_transfer: Optional[CCTPTransfer] = None


class Bridge(BaseModel):
    id: Optional[BridgeType] = None
    name: Optional[str] = Field(None, description='Name of the bridge')
    logo_uri: Optional[str] = Field(
        None, description='URI pointing to an image of the logo of the bridge'
    )


class Chain(BaseModel):
    chain_name: Optional[str] = Field(None, description='Name of the chain')
    chain_id: Optional[str] = Field(None, description='Chain-id of the chain')
    pfm_enabled: Optional[bool] = Field(
        None, description='Whether the PFM module is enabled on the chain'
    )
    cosmos_module_support: Optional[CosmosModuleSupport] = Field(
        None, description='Supported cosmos modules'
    )
    supports_memo: Optional[bool] = Field(
        None, description='Whether the chain supports IBC memos'
    )
    logo_uri: Optional[str] = Field(None, description='chain logo URI')
    bech32_prefix: Optional[str] = Field(None, description='Bech32 prefix of the chain')
    fee_assets: Optional[List[FeeAsset]] = Field(
        None, description='Fee assets of the chain'
    )
    chain_type: Optional[str] = Field(
        None, description='Type of chain, e.g. "cosmos" or "evm"'
    )
    ibc_capabilities: Optional[IbcCapabilities] = Field(
        None, description='IBC capabilities of the chain'
    )
    is_testnet: Optional[bool] = Field(
        None, description='Whether the chain is a testnet'
    )


class ContractCallWithTokenError(BaseModel):
    message: Optional[str] = Field(None, description='Error message')
    type: Optional[ContractCallWithTokenErrorType] = None


class ContractCallWithTokenTxs(BaseModel):
    approve_tx: Optional[ChainTransaction] = None
    confirm_tx: Optional[ChainTransaction] = None
    error: Optional[ContractCallWithTokenError] = None
    execute_tx: Optional[ChainTransaction] = None
    gas_paid_tx: Optional[ChainTransaction] = None
    send_tx: Optional[ChainTransaction] = None


class Error(BaseModel):
    code: Optional[GRPCStatusCode] = Field(None, description='Error code')
    details: Optional[List[ErrorDetail]] = Field(
        None, description='Additional error details'
    )
    message: Optional[str] = Field(None, description='Error message')


class HyperlaneTransferTransactions(BaseModel):
    send_tx: Optional[ChainTransaction] = None
    receive_tx: Optional[ChainTransaction] = None


class Msg(RootModel[Union[MultiChainMsgWrapper, EvmTxWrapper, SvmTxWrapper]]):
    root: Union[MultiChainMsgWrapper, EvmTxWrapper, SvmTxWrapper]


class PacketError(BaseModel):
    details: Optional[Union[Any, AcknowledgementErrorDetails]] = None
    message: Optional[str] = Field(None, description='Error message')
    type: Optional[PacketErrorType] = None


class SendTokenError(BaseModel):
    message: Optional[str] = Field(None, description='Error message')
    type: Optional[SendTokenErrorType] = None


class SendTokenTxs(BaseModel):
    confirm_tx: Optional[ChainTransaction] = None
    error: Optional[SendTokenError] = None
    execute_tx: Optional[ChainTransaction] = None
    send_tx: Optional[ChainTransaction] = None


class StatusError(BaseModel):
    details: Optional[TransactionExecutionErrorDetails] = None
    message: Optional[str] = Field(None, description='Error message')
    type: Optional[StatusErrorType] = None


class SwapExactCoinIn(BaseModel):
    """
    Specification of a swap with an exact amount in
    """

    swap_amount_in: Optional[str] = Field(None, description='Amount to swap in')
    swap_operations: Optional[List[SwapOperation]] = Field(
        None, description='Operations required to execute the swap'
    )
    swap_venue: Optional[SwapVenue] = Field(
        None, description='Swap venue that this swap should execute on'
    )
    price_impact_percent: Optional[str] = Field(
        None,
        description='Price impact of the estimated swap, if present.  Measured in percentage e.g. "0.5" is .5%',
    )


class SwapExactCoinOut(BaseModel):
    """
    Specification of a swap with an exact amount out
    """

    swap_amount_out: Optional[str] = Field(
        None, description='Amount to get out of the swap'
    )
    swap_operations: Optional[List[SwapOperation]] = Field(
        None, description='Operations required to execute the swap'
    )
    swap_venue: Optional[SwapVenue] = Field(
        None, description='Swap venue that this swap should execute on'
    )
    price_impact_percent: Optional[str] = Field(
        None,
        description='Price impact of the estimated swap, if present.  Measured in percentage e.g. "0.5" is .5%',
    )


class SwapInWrapper(BaseModel):
    swap_in: Optional[SwapExactCoinIn] = None


class SwapOutWrapper(BaseModel):
    swap_out: Optional[SwapExactCoinOut] = None


class AxelarTransfer1(BaseModel):
    axelar_scan_link: Optional[str] = Field(
        None, description='Link to the transaction on the Axelar Scan explorer'
    )
    to_chain_id: Optional[str] = Field(
        None, description='Chain ID of the destination chain'
    )
    from_chain_id: Optional[str] = Field(
        None, description='Chain ID of the source chain'
    )
    state: Optional[AxelarTransferState] = None
    txs: Optional[Union[ContractCallWithTokenTxs, SendTokenTxs]] = None
    type: Optional[AxelarTransferType] = None


class AxelarTransferInfo(BaseModel):
    axelar_transfer: Optional[AxelarTransfer1] = None


class CctpTransfer(BaseModel):
    to_chain_id: Optional[str] = Field(
        None, description='Chain ID of the destination chain'
    )
    from_chain_id: Optional[str] = Field(
        None, description='Chain ID of the source chain'
    )
    state: Optional[CCTPTransferState] = None
    txs: Optional[CCTPTransferTxs] = None


class CCTPTransferInfo(BaseModel):
    cctp_transfer: Optional[CctpTransfer] = None


class HyperlaneTransfer1(BaseModel):
    from_chain_id: Optional[str] = Field(
        None, description='Chain ID of the source chain'
    )
    to_chain_id: Optional[str] = Field(
        None, description='Chain ID of the destination chain'
    )
    state: Optional[HyperlaneTransferState] = None
    txs: Optional[HyperlaneTransferTransactions] = None


class HyperlaneTransferInfo(BaseModel):
    hyperlane_transfer: Optional[HyperlaneTransfer1] = None


class Packet(BaseModel):
    acknowledge_tx: Optional[ChainTransaction] = None
    error: Optional[PacketError] = None
    receive_tx: Optional[ChainTransaction] = None
    send_tx: Optional[ChainTransaction] = None
    timeout_tx: Optional[ChainTransaction] = None


class Swap1(SwapInWrapper):
    estimated_affiliate_fee: Optional[str] = Field(
        None, description='Estimated total affiliate fee generated by the swap'
    )
    chain_id: Optional[str] = Field(
        None, description='Chain id that the swap will be executed on'
    )
    denom_in: Optional[str] = Field(None, description='Input denom of the swap')
    denom_out: Optional[str] = Field(None, description='Output denom of the swap')


class Swap2(SwapOutWrapper):
    estimated_affiliate_fee: Optional[str] = Field(
        None, description='Estimated total affiliate fee generated by the swap'
    )
    chain_id: Optional[str] = Field(
        None, description='Chain id that the swap will be executed on'
    )
    denom_in: Optional[str] = Field(None, description='Input denom of the swap')
    denom_out: Optional[str] = Field(None, description='Output denom of the swap')


class Swap(RootModel[Union[Swap1, Swap2]]):
    root: Union[Swap1, Swap2]


class SwapWrapper(BaseModel):
    swap: Optional[Swap] = None


class TransferInfo(BaseModel):
    to_chain_id: Optional[str] = Field(
        None, description='Chain ID of the destination chain'
    )
    packet_txs: Optional[Packet] = None
    from_chain_id: Optional[str] = Field(
        None, description='Chain ID of the source chain'
    )
    state: Optional[TransferState] = None


class IBCTransferInfo(BaseModel):
    ibc_transfer: Optional[TransferInfo] = None


class Operation(
    RootModel[
        Union[
            TransferWrapper,
            SwapWrapper,
            AxelarTransferWrapper,
            BankSendWrapper,
            CCTPTransferWrapper,
            HyperlaneTransferWrapper,
        ]
    ]
):
    root: Union[
        TransferWrapper,
        SwapWrapper,
        AxelarTransferWrapper,
        BankSendWrapper,
        CCTPTransferWrapper,
        HyperlaneTransferWrapper,
    ]


class RouteResponse(BaseModel):
    amount_in: Optional[str] = Field(
        None, description='Amount of source asset to be transferred or swapped'
    )
    amount_out: Optional[str] = Field(
        None, description='Amount of destination asset out'
    )
    chain_ids: Optional[List[str]] = Field(
        None,
        description='Chain-ids of all chains of the transfer or swap, in order of usage by operations in the route',
    )
    dest_asset_chain_id: Optional[str] = Field(
        None, description='Chain-id of the destination asset'
    )
    dest_asset_denom: Optional[str] = Field(
        None, description='Denom of the destination asset'
    )
    does_swap: Optional[bool] = Field(
        None, description='Whether this route performs a swap'
    )
    estimated_amount_out: Optional[str] = Field(
        None, description='Amount of destination asset out, if a swap is performed'
    )
    operations: Optional[List[Operation]] = Field(
        None, description='Array of operations required to perform the transfer or swap'
    )
    source_asset_chain_id: Optional[str] = Field(
        None, description='Chain-id of the source asset'
    )
    source_asset_denom: Optional[str] = Field(
        None, description='Denom of the source asset'
    )
    swap_venue: Optional[SwapVenue] = Field(
        None,
        description='Swap venue on which the swap is performed, if a swap is performed',
    )
    txs_required: Optional[int] = Field(
        None,
        description='Number of transactions required to perform the transfer or swap',
    )
    usd_amount_in: Optional[str] = Field(
        None, description='Amount of the source denom, converted to USD value'
    )
    usd_amount_out: Optional[str] = Field(
        None,
        description='Amount of the destination denom expected to be received, converted to USD value',
    )
    swap_price_impact_percent: Optional[str] = Field(
        None,
        description='Price impact of the estimated swap, if present.  Measured in percentage e.g. "0.5" is .5%',
    )
    warning: Optional[Warning] = Field(
        None,
        description='Indicates if the route is unsafe due to poor execution price or if safety cannot be determined due to lack of pricing information',
    )
    estimated_fees: Optional[List[Fee]] = Field(
        None, description='Indicates fees incurred in the execution of the transfer'
    )


class TransferEvent(
    RootModel[
        Union[
            IBCTransferInfo, AxelarTransferInfo, CCTPTransferInfo, HyperlaneTransferInfo
        ]
    ]
):
    root: Union[
        IBCTransferInfo, AxelarTransferInfo, CCTPTransferInfo, HyperlaneTransferInfo
    ]


class TransferStatus(BaseModel):
    error: Optional[StatusError] = None
    next_blocking_transfer: Optional[NextBlockingTransfer] = Field(
        None,
        description='Indicates which entry in the `transfer_sequence` field that the transfer is blocked on. Will be null if there is no blocked transfer.',
    )
    state: Optional[TransactionState] = None
    transfer_asset_release: Optional[TransferAssetRelease] = Field(
        None, description='Indicates location and denom of transfer asset release.'
    )
    transfer_sequence: Optional[List[TransferEvent]] = Field(
        None, description='Lists any IBC and Axelar transfers as they are seen.'
    )
